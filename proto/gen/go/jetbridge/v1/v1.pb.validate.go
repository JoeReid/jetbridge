// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: jetbridge/v1/v1.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _v_1_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on ListPeersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPeersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPeersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPeersRequestMultiError, or nil if none found.
func (m *ListPeersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPeersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListPeersRequestMultiError(errors)
	}

	return nil
}

// ListPeersRequestMultiError is an error wrapping multiple validation errors
// returned by ListPeersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListPeersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPeersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPeersRequestMultiError) AllErrors() []error { return m }

// ListPeersRequestValidationError is the validation error returned by
// ListPeersRequest.Validate if the designated constraints aren't met.
type ListPeersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPeersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPeersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPeersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPeersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPeersRequestValidationError) ErrorName() string { return "ListPeersRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListPeersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPeersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPeersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPeersRequestValidationError{}

// Validate checks the field values on ListPeersResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPeersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPeersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPeersResponseMultiError, or nil if none found.
func (m *ListPeersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPeersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPeers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPeersResponseValidationError{
						field:  fmt.Sprintf("Peers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPeersResponseValidationError{
						field:  fmt.Sprintf("Peers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPeersResponseValidationError{
					field:  fmt.Sprintf("Peers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPeersResponseMultiError(errors)
	}

	return nil
}

// ListPeersResponseMultiError is an error wrapping multiple validation errors
// returned by ListPeersResponse.ValidateAll() if the designated constraints
// aren't met.
type ListPeersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPeersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPeersResponseMultiError) AllErrors() []error { return m }

// ListPeersResponseValidationError is the validation error returned by
// ListPeersResponse.Validate if the designated constraints aren't met.
type ListPeersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPeersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPeersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPeersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPeersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPeersResponseValidationError) ErrorName() string {
	return "ListPeersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPeersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPeersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPeersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPeersResponseValidationError{}

// Validate checks the field values on CreateBindingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBindingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBindingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBindingRequestMultiError, or nil if none found.
func (m *CreateBindingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBindingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetStream()) < 1 {
		err := CreateBindingRequestValidationError{
			field:  "Stream",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSubjectPattern()) < 1 {
		err := CreateBindingRequestValidationError{
			field:  "SubjectPattern",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for LambdaArn

	if all {
		switch v := interface{}(m.GetBatching()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBindingRequestValidationError{
					field:  "Batching",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBindingRequestValidationError{
					field:  "Batching",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBatching()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBindingRequestValidationError{
				field:  "Batching",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateBindingRequestMultiError(errors)
	}

	return nil
}

// CreateBindingRequestMultiError is an error wrapping multiple validation
// errors returned by CreateBindingRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateBindingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBindingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBindingRequestMultiError) AllErrors() []error { return m }

// CreateBindingRequestValidationError is the validation error returned by
// CreateBindingRequest.Validate if the designated constraints aren't met.
type CreateBindingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBindingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBindingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBindingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBindingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBindingRequestValidationError) ErrorName() string {
	return "CreateBindingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBindingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBindingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBindingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBindingRequestValidationError{}

// Validate checks the field values on CreateBindingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBindingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBindingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBindingResponseMultiError, or nil if none found.
func (m *CreateBindingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBindingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBinding()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBindingResponseValidationError{
					field:  "Binding",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBindingResponseValidationError{
					field:  "Binding",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBinding()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBindingResponseValidationError{
				field:  "Binding",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateBindingResponseMultiError(errors)
	}

	return nil
}

// CreateBindingResponseMultiError is an error wrapping multiple validation
// errors returned by CreateBindingResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateBindingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBindingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBindingResponseMultiError) AllErrors() []error { return m }

// CreateBindingResponseValidationError is the validation error returned by
// CreateBindingResponse.Validate if the designated constraints aren't met.
type CreateBindingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBindingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBindingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBindingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBindingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBindingResponseValidationError) ErrorName() string {
	return "CreateBindingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBindingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBindingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBindingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBindingResponseValidationError{}

// Validate checks the field values on GetBindingRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBindingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBindingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBindingRequestMultiError, or nil if none found.
func (m *GetBindingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBindingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = GetBindingRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetBindingRequestMultiError(errors)
	}

	return nil
}

func (m *GetBindingRequest) _validateUuid(uuid string) error {
	if matched := _v_1_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetBindingRequestMultiError is an error wrapping multiple validation errors
// returned by GetBindingRequest.ValidateAll() if the designated constraints
// aren't met.
type GetBindingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBindingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBindingRequestMultiError) AllErrors() []error { return m }

// GetBindingRequestValidationError is the validation error returned by
// GetBindingRequest.Validate if the designated constraints aren't met.
type GetBindingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBindingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBindingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBindingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBindingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBindingRequestValidationError) ErrorName() string {
	return "GetBindingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBindingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBindingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBindingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBindingRequestValidationError{}

// Validate checks the field values on GetBindingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBindingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBindingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBindingResponseMultiError, or nil if none found.
func (m *GetBindingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBindingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBinding()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBindingResponseValidationError{
					field:  "Binding",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBindingResponseValidationError{
					field:  "Binding",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBinding()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBindingResponseValidationError{
				field:  "Binding",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBindingResponseMultiError(errors)
	}

	return nil
}

// GetBindingResponseMultiError is an error wrapping multiple validation errors
// returned by GetBindingResponse.ValidateAll() if the designated constraints
// aren't met.
type GetBindingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBindingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBindingResponseMultiError) AllErrors() []error { return m }

// GetBindingResponseValidationError is the validation error returned by
// GetBindingResponse.Validate if the designated constraints aren't met.
type GetBindingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBindingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBindingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBindingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBindingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBindingResponseValidationError) ErrorName() string {
	return "GetBindingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBindingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBindingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBindingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBindingResponseValidationError{}

// Validate checks the field values on ListBindingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBindingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBindingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBindingsRequestMultiError, or nil if none found.
func (m *ListBindingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBindingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListBindingsRequestMultiError(errors)
	}

	return nil
}

// ListBindingsRequestMultiError is an error wrapping multiple validation
// errors returned by ListBindingsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListBindingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBindingsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBindingsRequestMultiError) AllErrors() []error { return m }

// ListBindingsRequestValidationError is the validation error returned by
// ListBindingsRequest.Validate if the designated constraints aren't met.
type ListBindingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBindingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBindingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBindingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBindingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBindingsRequestValidationError) ErrorName() string {
	return "ListBindingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBindingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBindingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBindingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBindingsRequestValidationError{}

// Validate checks the field values on ListBindingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBindingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBindingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBindingsResponseMultiError, or nil if none found.
func (m *ListBindingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBindingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBindings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBindingsResponseValidationError{
						field:  fmt.Sprintf("Bindings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBindingsResponseValidationError{
						field:  fmt.Sprintf("Bindings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBindingsResponseValidationError{
					field:  fmt.Sprintf("Bindings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListBindingsResponseMultiError(errors)
	}

	return nil
}

// ListBindingsResponseMultiError is an error wrapping multiple validation
// errors returned by ListBindingsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListBindingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBindingsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBindingsResponseMultiError) AllErrors() []error { return m }

// ListBindingsResponseValidationError is the validation error returned by
// ListBindingsResponse.Validate if the designated constraints aren't met.
type ListBindingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBindingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBindingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBindingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBindingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBindingsResponseValidationError) ErrorName() string {
	return "ListBindingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBindingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBindingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBindingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBindingsResponseValidationError{}

// Validate checks the field values on DeleteBindingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBindingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBindingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBindingRequestMultiError, or nil if none found.
func (m *DeleteBindingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBindingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = DeleteBindingRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteBindingRequestMultiError(errors)
	}

	return nil
}

func (m *DeleteBindingRequest) _validateUuid(uuid string) error {
	if matched := _v_1_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DeleteBindingRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteBindingRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBindingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBindingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBindingRequestMultiError) AllErrors() []error { return m }

// DeleteBindingRequestValidationError is the validation error returned by
// DeleteBindingRequest.Validate if the designated constraints aren't met.
type DeleteBindingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBindingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBindingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBindingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBindingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBindingRequestValidationError) ErrorName() string {
	return "DeleteBindingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBindingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBindingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBindingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBindingRequestValidationError{}

// Validate checks the field values on DeleteBindingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBindingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBindingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBindingResponseMultiError, or nil if none found.
func (m *DeleteBindingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBindingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteBindingResponseMultiError(errors)
	}

	return nil
}

// DeleteBindingResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteBindingResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteBindingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBindingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBindingResponseMultiError) AllErrors() []error { return m }

// DeleteBindingResponseValidationError is the validation error returned by
// DeleteBindingResponse.Validate if the designated constraints aren't met.
type DeleteBindingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBindingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBindingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBindingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBindingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBindingResponseValidationError) ErrorName() string {
	return "DeleteBindingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBindingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBindingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBindingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBindingResponseValidationError{}

// Validate checks the field values on Peer with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Peer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Peer with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PeerMultiError, or nil if none found.
func (m *Peer) ValidateAll() error {
	return m.validate(true)
}

func (m *Peer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = PeerValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateHostname(m.GetHostname()); err != nil {
		err = PeerValidationError{
			field:  "Hostname",
			reason: "value must be a valid hostname",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetJoined() == nil {
		err := PeerValidationError{
			field:  "Joined",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLastSeen() == nil {
		err := PeerValidationError{
			field:  "LastSeen",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetHeartbeatDue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PeerValidationError{
					field:  "HeartbeatDue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PeerValidationError{
					field:  "HeartbeatDue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeartbeatDue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PeerValidationError{
				field:  "HeartbeatDue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PeerMultiError(errors)
	}

	return nil
}

func (m *Peer) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Peer) _validateUuid(uuid string) error {
	if matched := _v_1_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PeerMultiError is an error wrapping multiple validation errors returned by
// Peer.ValidateAll() if the designated constraints aren't met.
type PeerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PeerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PeerMultiError) AllErrors() []error { return m }

// PeerValidationError is the validation error returned by Peer.Validate if the
// designated constraints aren't met.
type PeerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PeerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PeerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PeerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PeerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PeerValidationError) ErrorName() string { return "PeerValidationError" }

// Error satisfies the builtin error interface
func (e PeerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPeer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PeerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PeerValidationError{}

// Validate checks the field values on Binding with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Binding) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Binding with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BindingMultiError, or nil if none found.
func (m *Binding) ValidateAll() error {
	return m.validate(true)
}

func (m *Binding) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = BindingValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetStream()) < 1 {
		err := BindingValidationError{
			field:  "Stream",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetConsumer()) < 1 {
		err := BindingValidationError{
			field:  "Consumer",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSubjectPattern()) < 1 {
		err := BindingValidationError{
			field:  "SubjectPattern",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetLambdaArn()) < 1 {
		err := BindingValidationError{
			field:  "LambdaArn",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBatching()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BindingValidationError{
					field:  "Batching",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BindingValidationError{
					field:  "Batching",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBatching()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BindingValidationError{
				field:  "Batching",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BindingMultiError(errors)
	}

	return nil
}

func (m *Binding) _validateUuid(uuid string) error {
	if matched := _v_1_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// BindingMultiError is an error wrapping multiple validation errors returned
// by Binding.ValidateAll() if the designated constraints aren't met.
type BindingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindingMultiError) AllErrors() []error { return m }

// BindingValidationError is the validation error returned by Binding.Validate
// if the designated constraints aren't met.
type BindingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingValidationError) ErrorName() string { return "BindingValidationError" }

// Error satisfies the builtin error interface
func (e BindingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBinding.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingValidationError{}

// Validate checks the field values on BindingBatching with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BindingBatching) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindingBatching with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BindingBatchingMultiError, or nil if none found.
func (m *BindingBatching) ValidateAll() error {
	return m.validate(true)
}

func (m *BindingBatching) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMaxMessages() < 1 {
		err := BindingBatchingValidationError{
			field:  "MaxMessages",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMaxLatency() == nil {
		err := BindingBatchingValidationError{
			field:  "MaxLatency",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BindingBatchingMultiError(errors)
	}

	return nil
}

// BindingBatchingMultiError is an error wrapping multiple validation errors
// returned by BindingBatching.ValidateAll() if the designated constraints
// aren't met.
type BindingBatchingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindingBatchingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindingBatchingMultiError) AllErrors() []error { return m }

// BindingBatchingValidationError is the validation error returned by
// BindingBatching.Validate if the designated constraints aren't met.
type BindingBatchingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingBatchingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingBatchingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingBatchingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingBatchingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingBatchingValidationError) ErrorName() string { return "BindingBatchingValidationError" }

// Error satisfies the builtin error interface
func (e BindingBatchingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindingBatching.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingBatchingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingBatchingValidationError{}
